%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{STOA Documentation}
\date{Feb 08, 2019}
\release{0.8.0}
\author{Peter Hague}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{starting:introduction}}\label{\detokenize{starting::doc}}
Stoa is a workflow management system that keeps your code and data on a server and allows you and your collaborators to control them remotely through a web interface. It organises your data into worktables, into which your code is embedded through CWL (Common Workflow Language). Worktables are linked together into a higher level execution graph. STOA is able to take the output of any worktable and present it online as a service to others. At present, the services supported are fits format download, and VO cone search.

The central data structure in Stoa is the Worktable. Worktables encapsulate
workflows, written in CWL (Common Workflow Language), which define the inputs and
outputs of either a single command, or a workflow composed of multiple commands
with their inputs and outputs linked. A Worktable is also a table - whose columns
are defined by the inputs and outputs of the workflow. Once the user has written
a CWL workflow, a Worktable can be automatically generated from it.

The columns corresponding to the workflow outputs are read only, the columns corresponding
to the workflow input can be written to, and writing to them changes the status of a row
to indicate that the outputs no longer correspond to the inputs and the row needs to be
rerun. Stoa can handle this automatically.

Worktables are linked in a relational manner, so the output from one Worktable can be used
to populate the rows of another. For a trivial example, a simple worktable can encapsulate the Bash
command ‘find’ to locate all the folders in a large directory structure where a process
should be run. The output of this, one pathname per row, could be used to populate the input
columns of the Worktable encapsulating another process

Stoa is designed to operate complex processing pipelines across heterogenous
data sets. It does this mainly through Worktables - objects combining a workflow
object (written in CWL) with a data table. Any program can be inlcuded in a
Worktable.


\section{Getting Started}
\label{\detokenize{starting:getting-started}}
STOA requires Python 3 and some Python libraries, all available through \sphinxcode{\sphinxupquote{pip}} - we recommend that you use a virtual environment when trying this out.
When you have one set up, install \sphinxcode{\sphinxupquote{numpy}}, \sphinxcode{\sphinxupquote{astropy}}, \sphinxcode{\sphinxupquote{wltool}}, \sphinxcode{\sphinxupquote{grpcio-tools}} and \sphinxcode{\sphinxupquote{tornado}} and you should be good to go

In order to prepare STOA to run, type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{ready}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

this only need be done once per STOA install. Then type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./start.sh \PYGZdl{}PWD/example 9000
\end{sphinxVerbatim}

to run the demo. Go to your browser and visit “localhost:9000” to try it out


\section{First Use}
\label{\detokenize{starting:first-use}}
Login as admin (no password is required) and use \sphinxcode{\sphinxupquote{Create New User}} to add yourself as a user. Logout with the X icon on the left and then log back in with your username. No passwords are required at present; the current version is not designed to be visible outside private networks.

\noindent\sphinxincludegraphics{{newtable}.png}

Now create a worktable to implement the \sphinxcode{\sphinxupquote{find}} command. Click on the \sphinxcode{\sphinxupquote{Create New Worktable}} link and choose the workflow and yml file (which stores default values) then click \sphinxcode{\sphinxupquote{Create}}. The STOA install provides find.cwl and find.yml for testing purposes. Once the worktable is created, the screen should look like Figure 2. In order to run the worktable, it needs input for the workflow. Recall that each execution instance of a workflow is a row in the table, so in order to provide input for a workflow, we need to add a row. The dialogue box next to the ‘+’ sign can be used to type in a value for this workflow’s solitary input. Then click on + to add a row.

Once this table is present, go into it and add a new row with \sphinxcode{\sphinxupquote{product}} as its input, and then run that row.

\noindent\sphinxincludegraphics{{worktableview}.png}

At this point, there will be two pathnames from the example folder. This information will be passed on to the next worktable


\section{Creating Worktables}
\label{\detokenize{starting:creating-worktables}}
In order to create your own worktables in STOA, it is first necessary to create CWL wrappers for all the code you need. This is not typically difficult, and some wrappers for simple functions are included already for your convenience. There is a user guide for CWL at \sphinxurl{https://www.commonwl.org/user\_guide/} which will teach you the basics of the language and quickly get you writing wrappers for your own scripts. In brief, CWL describes the tools you use in terms of their inputs and outputs, and then lets you combine them into workflows with linked inputs and outputs.

Any command line tool whose operation is driven by its command line parameters, and can be modified to store all its output in a file named \sphinxcode{\sphinxupquote{cwl.output.json}}, will have a very simple wrapper. Future versions of STOA will include a way to automatically generate such wrappers.


\chapter{How worktables are processed}
\label{\detokenize{process:how-worktables-are-processed}}\label{\detokenize{process::doc}}
Execution in STOA is brooken up into ‘actions’, which are executions of a workflow with a specific set of input. Each row in a worktable (except those which do not yet have anything in the output fields) is a record of an action. Actions are pushed to a queue either by the user or by the automated recomputation system, and then removed from the queue and implemented by an action server.


\section{Action queue}
\label{\detokenize{process:action-queue}}
Each users had their own action queue, which at present only allows serial execution. The queue is cleared by a dedicated action server, so in a future version multiple action servers will be deployed in a swarm to clear the action queue in parallel. There will be no overhead in doing this, as actions must be by definition trivilally parallel and their results not depend on the order in which they are executed. This is in part up to the user, and STOA does not at this time perform any checks that would prevent a race condition if the user made two actions operate on the same data.

Each action consists of a list of inputs and the name of the worktable. It does not have a copy of the worktable, so whichever version is on the disk at the time the action is implemented will be used. This should be borne in mind by users who wish to continue workflow development whilst previous tasks are running.


\section{Execution}
\label{\detokenize{process:execution}}
After being removed from the queue by the action server, the worktables contents are unpacked into a temporary location, and the CWL workflow is run using the input parameters specified. CWL creates its own enviroment in which to run the workflow, and STOA adds the users folder to the PATH variable in this enviroment, so uploaded programs can be run.


\section{Output}
\label{\detokenize{process:output}}
Output bindings are processed as in CWL. However, if the stdout file is callecd ‘list.txt’ then it binds each line to an output.

The simplest way to send outputs back to CWL is to have programs write a JSON file called ‘cwl.output.json’ into their working directory.


\chapter{Design}
\label{\detokenize{design:design}}\label{\detokenize{design::doc}}
This is the main design document, which is primarily aimed at developers


\section{Overview}
\label{\detokenize{design:overview}}
\noindent\sphinxincludegraphics{{view1}.png}

The web interface initiates a WebSocket connection when started in order to drive the main UI. The web server is run as a separate process from the action server, which executes workflows. This means that continuous connectivity is not required to keep workflows running. Once the interface has highlighted which rows of which worktables need to be run, no further input via the web is required, and the user can close their browser and come back later.


\section{Data Model}
\label{\detokenize{design:data-model}}
Worktable are stored on the disk as zipped files, which always contain the following:
\begin{itemize}
\item {} 
A Common Workflow Language (CWL) file detailing the workflow

\item {} 
A Yaml file providing a row template

\item {} 
The table data

\end{itemize}

In addition, each Worktable may store any number of files, typically the individual steps of the workflow (as CWL files) and the program(s) that are to be invoked by the workflow. Data must only be stored inside the table itself, not in any auxilary files inside the worktable package.


\chapter{Functions}
\label{\detokenize{funcs:functions}}\label{\detokenize{funcs::doc}}
These functions are documented for completeness, most are not intended
for the end user to call directly


\section{Worktable module}
\label{\detokenize{funcs:module-worktable}}\label{\detokenize{funcs:worktable-module}}\index{worktable (module)@\spxentry{worktable}\spxextra{module}}

\section{Web Backend}
\label{\detokenize{funcs:module-backend}}\label{\detokenize{funcs:web-backend}}\index{backend (module)@\spxentry{backend}\spxextra{module}}\index{ConeSearchHandler (class in backend)@\spxentry{ConeSearchHandler}\spxextra{class in backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.ConeSearchHandler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{ConeSearchHandler}}}{\emph{application}, \emph{request}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{FitsHandler (class in backend)@\spxentry{FitsHandler}\spxextra{class in backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.FitsHandler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{FitsHandler}}}{\emph{application}, \emph{request}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{SocketHandler (class in backend)@\spxentry{SocketHandler}\spxextra{class in backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.SocketHandler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{SocketHandler}}}{\emph{application}, \emph{request}, \emph{**kwargs}}{}
Handler for WebSocket connections
\index{check\_origin() (backend.SocketHandler method)@\spxentry{check\_origin()}\spxextra{backend.SocketHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.SocketHandler.check_origin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_origin}}}{\emph{origin}}{}
To be implemented for security checks
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{origin}} \textendash{} Page originating WS request

\item[{Returns}] \leavevmode
Always “True” at the moment

\end{description}\end{quote}

\end{fulllineitems}

\index{on\_close() (backend.SocketHandler method)@\spxentry{on\_close()}\spxextra{backend.SocketHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.SocketHandler.on_close}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_close}}}{}{}
Closes WebSocket
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{on\_message() (backend.SocketHandler method)@\spxentry{on\_message()}\spxextra{backend.SocketHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.SocketHandler.on_message}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_message}}}{\emph{message}}{}
Responds to WS messages. Action is determined by first character
of message
\begin{itemize}
\item {} 
H: Home

\item {} 
F: Flag target

\item {} 
U: Unflag target

\item {} 
A/a: Get action list

\item {} 
P: Run a worktable

\item {} 
p: Run one row of a worktable

\item {} 
R/f: Run the specified action

\item {} 
r: Terminate an action

\item {} 
D: Display a file

\item {} 
C: Create new worktable

\item {} 
z: Clear contents of a worktable

\item {} 
k: Delete a worktable

\item {} 
t: Display a worktable

\item {} 
\&: Append to a worktable

\item {} 
s: Display a service

\item {} 
X: Logout

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{message}} \textendash{} WS message string

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{open() (backend.SocketHandler method)@\spxentry{open()}\spxextra{backend.SocketHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.SocketHandler.open}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{open}}}{}{}
Opens WebSocket
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{current() (in module backend)@\spxentry{current()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.current}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{current}}}{\emph{userip}}{}
Get the current folder being viewed by a user
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{userip}} \textendash{} The IP address of the user (currently used as ID)

\item[{Returns}] \leavevmode
The name of the folder

\end{description}\end{quote}

\end{fulllineitems}

\index{getwsroot() (in module backend)@\spxentry{getwsroot()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.getwsroot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{getwsroot}}}{\emph{userip}}{}
Get the address this user has to send ws connections to
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{userip}} \textendash{} The IP address of the user (currently used as ID)

\item[{Returns}] \leavevmode
A URL

\end{description}\end{quote}

\end{fulllineitems}

\index{projectInfo() (in module backend)@\spxentry{projectInfo()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.projectInfo}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{projectInfo}}}{\emph{userFolder}}{}
Produces the main page containing information about the current project
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
HTML output

\end{description}\end{quote}

\end{fulllineitems}

\index{setCurrent() (in module backend)@\spxentry{setCurrent()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.setCurrent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{setCurrent}}}{\emph{userip}, \emph{foldername}}{}
Sets the current folder being viewed by a user
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{userip}} \textendash{} The IP address of the user (currently used as ID)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{foldername}} \textendash{} The name of the folder

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{setTarget() (in module backend)@\spxentry{setTarget()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.setTarget}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{setTarget}}}{\emph{t}}{}
Sets the target folder
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} The name of the new target folder

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{startBackend() (in module backend)@\spxentry{startBackend()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.startBackend}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{startBackend}}}{}{}
Initialises the web database (distinct from the pipeline one) and
loads in user table
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{usercheck() (in module backend)@\spxentry{usercheck()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.usercheck}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{usercheck}}}{\emph{userip}}{}
Check if the user is valid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{userip}} \textendash{} The IP address of the user (currently used as ID)

\item[{Returns}] \leavevmode
A session ID, or “False” if there is no such user

\end{description}\end{quote}

\end{fulllineitems}

\index{xmlListing() (in module backend)@\spxentry{xmlListing()}\spxextra{in module backend}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:backend.xmlListing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{backend.}}\sphinxbfcode{\sphinxupquote{xmlListing}}}{\emph{path}}{}
Parses XML files stored in target folders
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} The path name of the folder containing the .xml file

\item[{Returns}] \leavevmode
List of subpaths (i.e. observations) defined in the file

\end{description}\end{quote}

\end{fulllineitems}



\section{User State}
\label{\detokenize{funcs:user-state}}\index{userState (class in userstate)@\spxentry{userState}\spxextra{class in userstate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:userstate.userState}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{userstate.}}\sphinxbfcode{\sphinxupquote{userState}}}~\index{appendQueue() (userstate.userState method)@\spxentry{appendQueue()}\spxextra{userstate.userState method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:userstate.userState.appendQueue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{appendQueue}}}{}{}
Add the contents of the process queue to the buffer
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{finalise() (userstate.userState method)@\spxentry{finalise()}\spxextra{userstate.userState method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{funcs:userstate.userState.finalise}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{finalise}}}{}{}
Checks if the process has finished, and if so performs finalisation operations
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\item {} 
\DUrole{xref,std,std-ref}{process}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{backend}\sphinxstyleindexpageref{funcs:\detokenize{module-backend}}
\indexspace
\bigletter{w}
\item\relax\sphinxstyleindexentry{worktable}\sphinxstyleindexpageref{funcs:\detokenize{module-worktable}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}